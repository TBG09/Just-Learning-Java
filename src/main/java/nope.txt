AppKeyListener.java:
import java.io.IOException;

public class AppKeyListener {
    boolean loop = true;

    public static void main(String[] args) {
        
    }


}
----------------------------------------
Number of non-empty lines: 6
Number of characters: 148
----------------------------------------
Arguments.java:
public class Arguments {
    // Static method to check if a specific argument is present in the array
    public static boolean argumentCheck(String argument, String[] args) {
        for (String arg : args) {
            if (arg.equals(argument)) {
                return true;
            }
        }
        return false;
    }
}
----------------------------------------
Number of non-empty lines: 11
Number of characters: 332
----------------------------------------
Config.java:
public class Config {

    private IOHandler.IO io;

    // Constructor
    public Config() {
        io = new IOHandler.IO();
        if (io != null) {
            Logger.info("ObjectInit - Config", "IOHandler object successfully initialized!");
        } else {
            Logger.fatal("ObjectInit - Config", "IOHandler object failed to initialize. :(");
            System.exit(1);
        }
    }

    // Public method to perform debug-related file operations
    public void debugToggle(boolean togglebool) {
        if (io.FileExists("config.txt")) {
            if (togglebool == true) {
                io.ReadOnlyChange("config.txt", true);
                io.write("config.txt", "debug=false");
                io.ReadOnlyChange("config.txt", false);
            } else {
                io.create("config.txt");
                io.ReadOnlyChange("config.txt", true);
                io.write("config.txt", "debug=false");
                io.ReadOnlyChange("config.txt", false);
            }

        }
    }
}

----------------------------------------
Number of non-empty lines: 28
Number of characters: 1023
----------------------------------------
ConsoleManagement.java:
import java.io.IOException;

public class ConsoleManagement {

    public static void clearConsole() {
        String os = System.getProperty("os.name").toLowerCase();

        try {
            if (os.contains("win")) {
                // Windows
                new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
            } else if (os.contains("nix") || os.contains("nux") || os.contains("mac")) {
                // Unix-like (Linux, macOS)
                new ProcessBuilder("clear").inheritIO().start().waitFor();
            } else {
                // Unsupported OS
                Logger.warn("ConsoleManagement","Unable to determine OS. Cannot clear console.");
            }
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {

        clearConsole();
        Logger.info("ConsoleManagement","Cleared Console!");
    }
}
----------------------------------------
Number of non-empty lines: 24
Number of characters: 954
----------------------------------------
DebugMode.java:
public class DebugMode {

    private static IOHandler.IO io = new IOHandler.IO(); // Assuming this is static


    // Constructor
    public DebugMode() {
        io = new IOHandler.IO(); // Initialize IOHandler

        // Check if initialization was successful
        if (io != null) {
            Logger.info("ObjectInit - DebugMode", "IOHandler object successfully initialized!");
        } else {
            Logger.fatal("ObjectInit - DebugMode", "IOHandler object failed to initialize. :(");
            System.exit(1); // Exit the application if initialization fails
        }
    }

    public static boolean isDebug() {

        String debugToggle = io.readContents("config.txt");
        if ("debug=true".equals(debugToggle.trim())) {
            Logger.info("DebugMode", "debug verified as true.");
            return true;
        } else {
            Logger.info("DebugMode", "debug verified as true.");
            return false;
        }

    }
}

----------------------------------------
Number of non-empty lines: 24
Number of characters: 965
----------------------------------------
HexadecimalHandler.java:
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;

public class HexadecimalHandler {
    // Read file and print its hexadecimal representation
    public static void handleFile(String filePath) {
        Logger.info("HexadecimalHandler", "Handling file: " + filePath);
        try {
            byte[] fileBytes = Files.readAllBytes(Paths.get(filePath));
            String hexString = bytesToHex(fileBytes);
            System.out.println(hexString);
        } catch (IOException e) {
            Logger.error("HexadecimalHandler", "Failed to read file: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    // Convert byte array to hexadecimal string
    public static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}
----------------------------------------
Number of non-empty lines: 27
Number of characters: 978
----------------------------------------
IOHandler.java:
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;

public class IOHandler {

    public static class IO {
        File myObj;
        File myObj2;

        public void create(String objectName) {
            try {
                myObj = new File(objectName); // Initialize myObj properly
                if (myObj.createNewFile())
                    Logger.info("IOHandler", "File " + objectName + " Created Successfully! :D");
            } catch (IOException e) {
                Logger.fatal("IOHandler", "An error occurred while trying to create your file: " + e);
            }
        }

        public String readContents(String filePath) {
            StringBuilder content = new StringBuilder(); // Use StringBuilder to accumulate file contents
            try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
                String line;
                while ((line = br.readLine()) != null) {
                    content.append(line).append(System.lineSeparator()); // Append each line and a new line separator
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            return content.toString(); // Return the accumulated content as a String
        }

        public void FileSize(String unit, String filePath) {
            File file = new File(filePath);
            if (!file.exists()) {
                Logger.error("IOHandler", "File does not exist: " + filePath);
                System.exit(1);
            }

            long fileSizeInBytes = file.length(); // Get file size in bytes

            double convertedSize = 0.0;
            switch (unit) {
                case "MB":
                    convertedSize = fileSizeInBytes / (1024.0 * 1024.0); // Convert bytes to megabytes
                    break;
                case "KB":
                    convertedSize = fileSizeInBytes / 1024.0; // Convert bytes to kilobytes
                    break;
                case "B":
                    convertedSize = fileSizeInBytes; // Already in bytes
                    break;
            }

            Logger.info("IOHandler", String.format("File size: %.2f %s", convertedSize, unit));
        }

        public boolean FileExists(String ObjectName) {
            try {
                        myObj = new File(ObjectName);
                        return myObj.exists();

            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public void delete(String objectName) {
            try {
                myObj = new File(objectName);
                if (myObj.delete()) {
                    Logger.info("IOHandler", "File " + objectName + " deleted successfully!");
                } else {
                    Logger.warn("IOHandler", "Your file couldn't be deleted :(");
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public void renameFile(String FileName, String FileAfterName) {
            myObj2 = new File(FileName);
            myObj2.renameTo(new File(FileAfterName));
            if (myObj2.renameTo(new File(FileAfterName))) {
                Logger.error("IOHandler", "File failed to be renamed");
            } else {
                Logger.info("IOHandler", "File Renamed Successfully");
            }
        }

        public static boolean isFileEmpty(String filePath) {
            File file = new File(filePath);

            // Check if file exists
            if (!file.exists()) {
                return false;
            }

            // Check if file is empty
            return file.length() == 0;
        }

        public void ReadOnlyChange(String objectName,Boolean ReadOnlyToggle) {
            myObj = new File(objectName);
            boolean writable = myObj.setWritable(ReadOnlyToggle);
        }

        public void write(String objectName, String writeData) {
            try (FileWriter myWriter = new FileWriter(objectName)) {
                myWriter.write(writeData);
                Logger.info("IOHandler", "Successfully wrote to the file.");
            } catch (IOException e) {
                Logger.fatal("IOHandler", "An error occurred while trying to write to the file: " + e);
            }
        }
    }
}
----------------------------------------
Number of non-empty lines: 103
Number of characters: 4404
----------------------------------------
LogFile.java:
import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class LogFile {
    public static final String LOG_DIRECTORY = "logs";
    public static final String LOG_FILE_PREFIX = "log_";
    public static final String LOG_FILE_SUFFIX = ".log";
    public static final long UPDATE_INTERVAL_MS = 300; // 0.3 seconds

    public static PrintStream originalOut;
    public static PrintStream originalErr;
    public static StringBuilder currentInput = new StringBuilder();
    public static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();



    public static void setupLogging() {
        try {
            // Ensure the logs directory exists
            File logDir = new File(LOG_DIRECTORY);
            if (!logDir.exists()) {
                logDir.mkdirs();
            }

            // Create a log file with the current date and time
            String logFileName = LOG_FILE_PREFIX + new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date()) + LOG_FILE_SUFFIX;
            File logFile = new File(logDir, logFileName);

            // Save the original System.out and System.err
            originalOut = System.out;
            originalErr = System.err;

            // Redirect System.out and System.err to the log file
            PrintStream logStream = new PrintStream(new FileOutputStream(logFile, true), true);
            System.setOut(new PrintStream(new MultiOutputStream(System.out, logStream), true));
            System.setErr(new PrintStream(new MultiOutputStream(System.err, logStream), true));

            Logger.info("LogFile", "Logging started. Output will be written to " + logFile.getAbsolutePath());

            // Start the periodic update task
            startPeriodicUpdate(logStream);
        } catch (IOException e) {
            Logger.error("LogFile", "Failed to set up logging: " + e.getMessage());
        }
    }

    public static void startPeriodicUpdate(PrintStream logStream) {
        executor.scheduleAtFixedRate(() -> {
            synchronized (currentInput) {
                if (currentInput.length() > 0) {
                    logStream.println(currentInput.toString());
                    logStream.flush();
                    currentInput.setLength(0); // Clear the input after logging
                }
            }
        }, 0, UPDATE_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    public static class MultiOutputStream extends OutputStream {
        public final OutputStream[] outputStreams;

        public MultiOutputStream(OutputStream... outputStreams) {
            this.outputStreams = outputStreams;
        }

        @Override
        public void write(int b) throws IOException {
            for (OutputStream os : outputStreams) {
                os.write(b);
            }
        }

        @Override
        public void flush() throws IOException {
            for (OutputStream os : outputStreams) {
                os.flush();
            }
        }

        @Override
        public void close() throws IOException {
            for (OutputStream os : outputStreams) {
                os.close();
            }
        }
    }

    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            System.out.println("Start typing your input:");
            String line;
            while ((line = reader.readLine()) != null) {
                synchronized (currentInput) {
                    currentInput.append(line).append("\n");
                }
            }
        } catch (IOException e) {
            Logger.error("LogFile", "Error reading user input: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
}
----------------------------------------
Number of non-empty lines: 90
Number of characters: 3909
----------------------------------------
Logger.java:
import java.text.SimpleDateFormat;
import java.util.Date;

public class Logger {

    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_YELLOW = "\u001B[33m";
    private static final String ANSI_CYAN = "\u001B[36m";
    private static final String ANSI_BRIGHT_RED = "\u001B[91m";
    private static final String ANSI_RESET = "\u001B[0m";

    // Method to log INFO messages
    public static void info(String source, String message) {
        log(source, "INFO", message, ANSI_RESET);
    }

    // Method to log WARN messages
    public static void warn(String source, String message) {
        log(source, "WARN", message, ANSI_YELLOW);
    }

    // Method to log ERROR messages
    public static void error(String source, String message) {
        log(source, "ERROR", message, ANSI_RED);
    }

    // Method to log FATAL messages
    public static void fatal(String source, String message) {
        log(source, "FATAL", message, ANSI_BRIGHT_RED);
    }

    public static void debug(String source, String message) {
        log(source, "DEBUG", message, ANSI_CYAN);
    }

    // Private method to format and print the log message
    private static void log(String source, String level, String message, String color) {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
        String dateString = formatter.format(new Date());
        System.out.println("[" + dateString + "] [" + color + source + ANSI_RESET + "/" + color + level + ANSI_RESET + "] " + color + message + ANSI_RESET);
    }
}

----------------------------------------
Number of non-empty lines: 34
Number of characters: 1577
----------------------------------------
Main.java:
import java.awt.event.KeyEvent;
import java.io.File;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.CountDownLatch;

public class Main {
    private static final CountDownLatch latch = new CountDownLatch(1);

    public static void main(String[] args) throws InterruptedException {
        Boolean argumentCheck = true;
        Boolean onlineMode = true;

        StartupJobs.main(args);

        Logger.info("Main", "Started! Hello from dev!");

        DebugMode debugMode = new DebugMode();
        if (debugMode != null) {
            Logger.info("ObjectInit", "DebugMode object successfully initialized!");
        } else {
            Logger.warn("ObjectInit", "DebugMode object failed to initialize :(");
        }

        StartupJobs startupJobs = new StartupJobs(); // No check for if it's valid or not.

        if (DebugMode.isDebug()) {
            Logger.debug("Main", "Running build 0068");
            Logger.debug("Main", "Running on " + startupJobs.osName + " " + startupJobs.osVersion + " on  an " + startupJobs.deviceArch + ".");
        } else {

        }


        // Initialize Arguments object
        Arguments arguments = new Arguments();
        if (arguments != null) {
            Logger.info("ObjectInit", "Arguments object successfully initialized!");
        } else {
            Logger.warn("ObjectInit", "Arguments object failed to initialize, skipping argument check.");
            Logger.info("HexadecimalHandler", "HexadecimalHandler loaded!");
            argumentCheck = false;
        }

        // Initialize Window object
        Window window = new Window();
        if (window != null) {
            Logger.info("ObjectInit", "Window object successfully initialized!");
        } else {
            Logger.warn("ObjectInit", "Window object failed to initialize, skipping argument check.");
        }

        // Initialize Scanner object
        Scanner scanner = new Scanner(System.in);
        if (scanner != null) {
            Logger.info("ObjectInit", "Scanner object successfully initialized!");
        } else {
            Logger.fatal("ObjectInit", "Scanner object failed to initialize. :(");
            System.exit(1);
        }

        // Initialize IOHandler object
        IOHandler.IO io = new IOHandler.IO();
        if (io != null) {
            Logger.info("ObjectInit", "IOHandler object successfully initialized!");
        } else {
            Logger.fatal("ObjectInit", "IOHandler object failed to initialize. :(");
            System.exit(1);
        }

            Config config = new Config();


        // Get the runtime instance
        Runtime runtime = Runtime.getRuntime();
        if (runtime != null) {
            Logger.info("ObjectInit", "Runtime object successfully initialized!");
        } else {
            Logger.warn("ObjectInit", "Runtime object failed to initialize. :(");
        }

        // Get the total memory allocated to the JVM
        assert runtime != null;
        long totalMemory = runtime.totalMemory();
        long totalMemoryMB = totalMemory / (1024 * 1024);
        if (totalMemory == 0) {
            Logger.warn("Main", "Failed to retrieve allocated memory or is somehow 0 (i have no idea how that is possible).");
        } else {
            Logger.info("Main", "Allocated memory is " + totalMemory + " Bytes or " + totalMemoryMB + " MegaBytes");
        }

        // Check if running on Termux
        boolean runningOnTermux = isRunningOnTermux();
        if (runningOnTermux) {
            Logger.info("Main", "Running on Termux! Skipping window creation.");
        }

        // Check for custom arguments if argumentCheck is true
        if (argumentCheck) {
            Logger.info("Main", "Checking for custom arguments...");

            boolean hasCustomArgument = false;

            // Check for "help" argument
            if (Arguments.argumentCheck("help", args)) {
                System.out.println("Version 4.2.2");
                System.out.println("properties - this shows properties of files, not folders.");
                System.out.println("window - opens the test window.");
                System.out.println("credits - shows credits.");
                System.out.println("changelog - shows the changelog.");
                System.out.println("snake - launches the game snake.");
                System.out.println("That's all lol.");
                System.exit(0);
            } else if (Arguments.argumentCheck("properties", args)) {
                // Check for "properties" argument
                hasCustomArgument = true;
                System.out.print("Tell me the unit to use as size: ");
                String UserpropertiesFileSize = scanner.nextLine();
                if (!"MB".equals(UserpropertiesFileSize) && !"KB".equals(UserpropertiesFileSize) && !"B".equals(UserpropertiesFileSize)) {
                    System.out.println("ERROR: The file unit provided is not a valid unit.");
                    System.exit(1);
                }
                System.out.print("Tell me the file you want to get the properties of: ");
                String UserpropertiesFile = scanner.nextLine();
                System.out.println("K got it! Here are the properties");
                System.out.println("Filename " + UserpropertiesFile);
                io.FileSize(UserpropertiesFileSize, UserpropertiesFile);
                System.exit(0);
            } else if (Arguments.argumentCheck("window", args) && (totalMemoryMB >= 16)) {
                // Check for "window" argument and sufficient memory
                if (!runningOnTermux) {
                    hasCustomArgument = true;
                    Logger.info("Main", "Window Launching!");
                    window.StartWindow("Just Learn java 4.1.1(Test Window)");
                    Logger.info("Main", "Not a termux environment, continuing with window launch.");
                    latch.await(); // Wait until the window is closed
                } else {
                    Logger.error("Main", "Window launch canceled due to being ran in a Termux environment.");
                    System.exit(1);
                }
            } else if (Arguments.argumentCheck("window", args)) {
                Logger.error("Main", "Memory amount does not meet requirements to launch window.");
                System.out.println("ERROR: Memory amount does not meet requirements to launch window.");
                System.out.println("Sorry try launching the window with at least 16 MB of memory to the jar.");
                System.exit(1);
            }
        }
        else {
            Logger.info("Main", "No argumentCheck is needed. Continuing with the application.");
        }

        if (Arguments.argumentCheck("hexadecimal", args)) {
            System.out.println("What file do you want to get the hex data out of?");
            String FileObjectHexData = scanner.nextLine();
            if (io.isFileEmpty(FileObjectHexData)) {
                Logger.error("Main - HexadecimalHandler", "File is empty, unable to retreive any data.");
                System.exit(1);
            } else  {
                if (io.FileExists(FileObjectHexData)) {
                    HexadecimalHandler.handleFile(FileObjectHexData);
                    System.exit(0);
                }
            }

        }

        if (Arguments.argumentCheck("credits", args)) {
            ConsoleManagement.clearConsole();
            Logger.info("Arguments", "Displaying credits!");
            System.out.println("97% coded by Bluelist");
            System.out.println("3% Code given by Chatgpt and thank you to chatgpt for helping me :D");
            System.exit(0);
        }

        if (Arguments.argumentCheck("changelog",args)) {
            System.out.println("Changes in version 4.2.2.0068-dev1:");
            System.out.println("Fixed a few strings");
            System.out.println("Added debug option");
            System.out.println("Extra info displayed with debug");
            System.exit(0);
        }

        if (Arguments.argumentCheck("snake", args)) {
            Logger.info("Main", "Starting method SnakeGame.");
            String[] snakeGameArgs = {"snake"};
            SnakeGame.main(snakeGameArgs);
            latch.await();
        }
        if (Arguments.argumentCheck("debug", args)) {
            if (debugMode.isDebug()) {
                System.out.println("1) Force a random error, or fatal error.");
            }   else {
                System.exit(0);
            }

        }
        if (Arguments.argumentCheck("debug-toggle", args)) {
            config.debugToggle(true);
            if (Boolean.parseBoolean(io.readContents(String.valueOf("config.txt".equals("debug=false"))))) {
                config.debugToggle(true);
            } else {
                config.debugToggle(false);
            }
        }

        // Continue with displaying options and handling user input if not in Termux
        if (!runningOnTermux) {
            System.out.println("What do you want to do?");
            TimeUnit.SECONDS.sleep((long) 1.5); // Sleep for 1.5 seconds
            System.out.println("1) Create a file");
            System.out.println("2) Write data to a file");
            System.out.println("3) Delete a file");
            System.out.println("4) Rename a file");
            System.out.println("5) Set read-only property to true or false");
            Integer UserOption = Integer.valueOf(scanner.nextLine());

            // Handle user option for creating a file
            if (UserOption.equals(1)) {
                System.out.println("You want to create a file? Alright fine by me.");
                System.out.print("Tell me the file you want to create, you can put the path to it as well: ");
                String UserFileName = scanner.nextLine();
                io.create(UserFileName);
                System.out.println("Alright I made your file! " + UserFileName);
                System.out.println("Enjoy your new file!");
                System.exit(0);
            } else if (UserOption.equals(2)) {
                // Handle user option for writing data to a file
                System.out.println("Alright sure lets write something!");
                System.out.print("Tell what file you want to write to: ");
                String UserFileNameData = scanner.nextLine();
                if (io.FileExists(UserFileNameData)) {
                    System.out.print("Alright, now tell me what you want to write to it: ");
                    String UserFileData = scanner.nextLine();
                    io.write(UserFileNameData, UserFileData);
                    System.out.println("Alright I have added the data to file " + UserFileNameData + ", Enjoy!");
                    System.exit(0);
                } else {
                    TimeUnit.SECONDS.sleep(2); // Sleep for 2 seconds
                    System.exit(1);
                }
            } else if (UserOption.equals(3)) {
                // Handle user option for deleting a file
                System.out.println("Alright, just don't delete system files.");
                System.out.print("What file do you want to delete? Provide a path or just the file: ");
                String UserFileDelete = scanner.nextLine();
                if (io.FileExists(UserFileDelete)) {
                    System.out.println("The file has been deleted!");
                    io.delete(UserFileDelete);
                    TimeUnit.SECONDS.sleep(2); // Sleep for 2 seconds
                    System.exit(0);
                } else {
                    io.delete(UserFileDelete);
                    TimeUnit.SECONDS.sleep(2); // Sleep for 2 seconds
                    System.exit(1);
                }


            } else if (UserOption.equals(4)) {

                System.out.println("What file do you want to rename?");
                String UserRenameFile = scanner.nextLine();
                if (io.FileExists(UserRenameFile)) {
                    System.out.println("And rename what to?");
                    String UserRenameFileResult = scanner.nextLine();
                    io.renameFile(UserRenameFile, UserRenameFileResult);
                } else {
                    Logger.error("Main - IOHandler", "File does not exist: ");
                            TimeUnit.SECONDS.sleep((long) 2.5);
                    System.exit(1);
                }
            } else if (UserOption.equals(5)) {
                System.out.println("What file do you want to change the property on?");
                String UserReadOnlyFile = scanner.nextLine();
                if (io.FileExists(UserReadOnlyFile)) {
                    System.out.println("Now do you want to turn it off or on? (false being on and true being off)");
                    Boolean userReadOnlyPropertyAnswer = Boolean.valueOf(scanner.nextLine());
                    if (userReadOnlyPropertyAnswer.equals("true")) {
                        io.ReadOnlyChange(UserReadOnlyFile, userReadOnlyPropertyAnswer);
                    } else {
                        io.ReadOnlyChange(UserReadOnlyFile, userReadOnlyPropertyAnswer);
                    }

                } else {
                    Logger.error("Main - IOHandler", "File does not exist: ");
                    TimeUnit.SECONDS.sleep((long) 2.5);
                    System.exit(1);
                }




            } else {


                System.out.println("Uhhh that isn't an option...");
                System.exit(1);
            }
        } else {
            Logger.info("Main", "No interactive options available in Termux.");
        }
    }

    private static boolean isRunningOnTermux() {
        File termuxFile = new File("/data/data/com.termux/files/home/.termux");
        return termuxFile.exists() && termuxFile.isDirectory();
    }
}
----------------------------------------
Number of non-empty lines: 267
Number of characters: 13907
----------------------------------------
SnakeGame.java:
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class SnakeGame extends JPanel implements ActionListener, KeyListener {
    private final int SIZE = 20, WIDTH = 400, HEIGHT = 400;
    private int[] x = {100, 80, 60}, y = {100, 100, 100};
    private int appleX = 200, appleY = 200, direction = KeyEvent.VK_RIGHT;
    private Timer timer = new Timer(100, this);

    public SnakeGame() {
        try {
            setPreferredSize(new Dimension(WIDTH, HEIGHT));
            setBackground(Color.BLACK);
            setFocusable(true);
            addKeyListener(this);
            timer.start();
            Logger.info("SnakeGame", "Game started.");
        } catch (Exception e) {
            Logger.fatal("SnakeGame", "Critical error during initialization: " + e.getMessage());
            System.exit(1);
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        g.setColor(Color.RED);
        g.fillRect(appleX, appleY, SIZE, SIZE);
        g.setColor(Color.GREEN);
        for (int i = 0; i < x.length; i++) g.fillRect(x[i], y[i], SIZE, SIZE);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        try {
            int prevX = x[0], prevY = y[0];
            int tempX, tempY;
            switch (direction) {
                case KeyEvent.VK_LEFT: x[0] -= SIZE; break;
                case KeyEvent.VK_RIGHT: x[0] += SIZE; break;
                case KeyEvent.VK_UP: y[0] -= SIZE; break;
                case KeyEvent.VK_DOWN: y[0] += SIZE; break;
            }

            // Handle border wrap
            if (x[0] < 0) x[0] = WIDTH - SIZE;
            if (x[0] >= WIDTH) x[0] = 0;
            if (y[0] < 0) y[0] = HEIGHT - SIZE;
            if (y[0] >= HEIGHT) y[0] = 0;

            // Move the snake body
            for (int i = 1; i < x.length; i++) {
                tempX = x[i]; tempY = y[i];
                x[i] = prevX; y[i] = prevY;
                prevX = tempX; prevY = tempY;
            }

            // Check for collision with itself
            for (int i = 1; i < x.length; i++) {
                if (x[0] == x[i] && y[0] == y[i]) {
                    Logger.info("SnakeGame", "Game over: Snake collided with itself.");
                    JOptionPane.showMessageDialog(this, "You Lose!", "Snake Game", JOptionPane.INFORMATION_MESSAGE);

                    System.exit(0);
                }
            }

            // Check for apple collision
            if (x[0] == appleX && y[0] == appleY) {
                appleX = (int) (Math.random() * (WIDTH / SIZE)) * SIZE;
                appleY = (int) (Math.random() * (HEIGHT / SIZE)) * SIZE;
                x = java.util.Arrays.copyOf(x, x.length + 1);
                y = java.util.Arrays.copyOf(y, y.length + 1);
                Logger.info("SnakeGame", "Apple eaten: New apple position (" + appleX + "," + appleY + ")");
            }

            repaint();
        } catch (Exception ex) {
            Logger.fatal("SnakeGame", "Critical error during game update: " + ex.getMessage());
            System.exit(1);
        }
    }

    @Override
    public void keyPressed(KeyEvent e) {
        int newDirection = e.getKeyCode();
        if (newDirection == KeyEvent.VK_W) newDirection = KeyEvent.VK_UP;
        if (newDirection == KeyEvent.VK_S) newDirection = KeyEvent.VK_DOWN;
        if (newDirection == KeyEvent.VK_A) newDirection = KeyEvent.VK_LEFT;
        if (newDirection == KeyEvent.VK_D) newDirection = KeyEvent.VK_RIGHT;

        // Check if the new direction is valid
        if (Math.abs(newDirection - direction) != KeyEvent.VK_UP - KeyEvent.VK_DOWN &&
                Math.abs(newDirection - direction) != KeyEvent.VK_LEFT - KeyEvent.VK_RIGHT &&
                !willHitSnake(newDirection)) {
            direction = newDirection;
            Logger.info("SnakeGame", "Direction changed to: " + direction);
        }
    }

    private boolean willHitSnake(int newDirection) {
        int newX = x[0], newY = y[0];
        switch (newDirection) {
            case KeyEvent.VK_LEFT: newX -= SIZE; break;
            case KeyEvent.VK_RIGHT: newX += SIZE; break;
            case KeyEvent.VK_UP: newY -= SIZE; break;
            case KeyEvent.VK_DOWN: newY += SIZE; break;
        }
        for (int i = 0; i < x.length; i++) {
            if (newX == x[i] && newY == y[i]) return true;
        }
        return false;
    }

    @Override
    public void keyReleased(KeyEvent e) { }
    @Override
    public void keyTyped(KeyEvent e) { }

    public static void main(String[] args) {
        try {
            JFrame frame = new JFrame("Snake Game");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.add(new SnakeGame());
            frame.pack();
            frame.setVisible(true);
            Logger.info("SnakeGame", "Game window initialized and visible.");
        } catch (Exception e) {
            Logger.fatal("SnakeGame", "Critical error during window initialization: " + e.getMessage());
            System.exit(1);
        }
    }
}

----------------------------------------
Number of non-empty lines: 119
Number of characters: 5095
----------------------------------------
StartupJobs.java:
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class StartupJobs {

    public String osName;
    public String javaVer;
    public String deviceArch;
    public String osVersion;


    public void FirstChecks() {
        String osName = System.getProperty("os.name");
        String javaVer = System.getProperty("java.version");
        String deviceArch = System.getProperty("os.arch");
        String osVersion = System.getProperty("os.version");
    }


    public static void main(String[] args) {
        String directoryPath = "logs"; // Directory to be created


        Path path = Paths.get(directoryPath);

        try {
            if (Files.notExists(path)) {
                Files.createDirectories(path);
                Logger.info("StartupJobs", "Directory created: " + directoryPath);
            } else {
                Logger.info("StartupJobs", "Directory already exists: " + directoryPath);
            }
        } catch (IOException e) {
            Logger.error("StartupJobs", "Failed to create directory: " + e.getMessage());
        }
            LogFile.setupLogging();
        Logger.info("StartupJobs","Started setupLogging");
    }
}
----------------------------------------
Number of non-empty lines: 32
Number of characters: 1236
----------------------------------------
Window.java:
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.*;
import java.util.concurrent.TimeUnit;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class Window {
    private int squareX = 100;  // Initial x position of the square
    private int squareY = 100;  // Initial y position of the square

    // Method to start a new window with the specified title
    public void StartWindow(String WindowTitle) throws InterruptedException {
        Logger.info("WindowHandler", "Starting window with title: " + WindowTitle);

        // Create a new JFrame instance
        JFrame frame = new JFrame(WindowTitle);
        Logger.info("WindowHandler", "JFrame created with title: " + WindowTitle);

        // Set the default close operation
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Logger.info("WindowHandler", "Default close operation set.");
        System.out.println("If it says certain things twice, ignore its fine.");
        TimeUnit.SECONDS.sleep(3);

        // Create a JPanel to hold the components
        JPanel Mainpanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                // Set the color for the cube
                g.setColor(Color.BLUE);
                // Draw the cube (rectangle) at position (squareX, squareY)
                g.fillRect(squareX, squareY, 50, 50);
            }
        };
        Logger.info("WindowHandler", "JPanel Mainpanel created.");

        // Set the JPanel to be focusable and request focus
        Mainpanel.setFocusable(true);
        Mainpanel.requestFocusInWindow();

        // Add a KeyListener to handle key events
        Mainpanel.addKeyListener(new KeyListener() {
            @Override
            public void keyPressed(KeyEvent e) {
                int keyCode = e.getKeyCode();

                // Update position based on arrow keys
                if (keyCode == KeyEvent.VK_RIGHT) {
                    squareX += 5;  // Move square to the right
                    Logger.info("WindowHandler - KeyListener", "VK_RIGHT Pressed.");
                } else if (keyCode == KeyEvent.VK_DOWN) {
                    squareY += 5;  // Move square down
                    Logger.info("WindowHandler - KeyListener", "VK_DOWN Pressed.");
                } else if (keyCode == KeyEvent.VK_LEFT) {
                    squareX -= 5;  // Move square left
                    Logger.info("WindowHandler - KeyListener", "VK_LEFT Pressed.");
                } else if (keyCode == KeyEvent.VK_UP) {
                    squareY -= 5;  // Move square up
                    Logger.info("WindowHandler - KeyListener", "VK_UP Pressed.");
                }

                // Repaint the panel to reflect the changes
                Mainpanel.repaint();
            }

            @Override
            public void keyReleased(KeyEvent e) {
                // No action needed on key release
            }

            @Override
            public void keyTyped(KeyEvent e) {
                // No action needed on key typed
            }
        });

        Logger.info("WindowHandler", "ActionListener added to testButton.");

        // Create a JButton
        JButton testButton = new JButton("testing");
        Logger.info("WindowHandler", "JButton testButton created.");

        testButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Logger.info("ButtonHandler", "Test button was clicked.");
            }
        });

        // Add the button to the panel
        Mainpanel.add(testButton);
        Logger.info("WindowHandler", "JButton testButton added to JPanel Mainpanel.");

        // Add the panel to the frame
        frame.add(Mainpanel);
        Logger.info("WindowHandler", "JPanel Mainpanel added to JFrame.");

        // Set the size of the window
        frame.setSize(400, 300);
        Logger.info("WindowHandler", "JFrame size set to 400x300.");

        // Make the window visible
        frame.setVisible(true);
        Logger.info("WindowHandler", "JFrame set to visible.");
    }

    public static void main(String[] args) throws InterruptedException {
        new Window().StartWindow("KeyListener Example");
    }
}

----------------------------------------
Number of non-empty lines: 94
Number of characters: 4395
----------------------------------------